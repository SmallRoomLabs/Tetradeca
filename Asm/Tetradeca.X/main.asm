;-----------------------------------------------------------------------------
; Tetradeca - A multi-game unit using 14 segment LED displays and a PIC16F1705
;-----------------------------------------------------------------------------
;
; The files for the full project are located at 
; github.com/SmallRoomLabs/Tetradeca
;
; Copyright (c) 2016 Mats Engstrom SmallRoomLabs
; Released under the MIT license
;
; This project is an entry for the Hackaday 1kB Competition:
; hackaday.io/contest/18215-the-1kb-challenge    
; The size of the code and data tables are limited to 1024 bytes in total. 
; Since the PIC16-series have a 14 bit code architecture so the 1024 bytes 
; only allows for 1024*8/14=585 "words"
;
; Games:
;  * CRACK  Four letter word Mastermind  (dissabled)
;  * TONES  Eight-button Simon           (enabled)
;  * ZEONE  Decimal-to-Binary conversion (enabled)
;  * SORTS  Sort-the-letters             (enabled)
;
; The current code size with CRACK disabled is 554 14-bit words = 970 bytes.
;
; Credits and acknowledgements - I've used code from the sources below. I
; didn't find any license information for them, but I boldly assume they are
; released into the public domain, one being generated by an online tool, the
; other being published by the awesome Mike McLaren in multiple forums when
; replying to people asking about quadrature encoders. 
;  
;   * piclist.com/techref/piclist/codegen/delay.htm for the delay subroutine
;   * Mike McLaren K8LH for the Quadrature Encoder decoder snippet 
;   * Microchip AN544 for the Random number generator
;
; Some general PIC tips & tricks pages that came to good use:
;   * picprojects.org.uk/projects/pictips.htm
;

    RADIX DEC           ; Use decimal numbers by default
    ERRORLEVEL -302     ; Kill messages about "Register not in bank 0"
    ERRORLEVEL -305     ; Kill messages about "Using default destination"

    #include "p16f1705.inc"
 
    __CONFIG _CONFIG1, _FOSC_INTOSC & _WDTE_OFF & _PWRTE_OFF & _MCLRE_ON & _CP_OFF & _BOREN_OFF & _CLKOUTEN_OFF & _IESO_OFF & _FCMEN_OFF
    __CONFIG _CONFIG2, _WRT_OFF & _PPS1WAY_OFF & _ZCDDIS_ON & _PLLEN_ON & _STVREN_ON & _BORV_LO & _LPBOR_OFF & _LVP_ON


;
;  A0 in  ICSPDAT               16F1705                 '595
;  A1 in  ICSPCLK               +--v--+                +--v--+
;  A2 in  Rotary-Button       - |1  14| +            QB|1  16| +
;  A3 in  ICSPRES            A5 |2  13| RA0/ISPDAT   QC|2  15| QA
;  A4 out 595-Latch          A4 |3  12| RA1/ISPCLK   QD|3  14| SerIn
;  A5 in  <unused>       RES/A3 |4  11| RA2          QE|4  13| /OE
;  C0 in  <unused>           C5 |5  10| C0           QF|5  12| LATCH
;  C1 in  Rotary-A           C4 |6   9| C1           QG|6  11| CLOCK
;  C2 in  Rotary-B           C3 |7   8| C2           QH|7  10| /CLEAR
;  C3 in  Buttons               +-----+              - |8   9| SerOut
;  C4 out 595-DataIn                                  +-----+
;  C5 out 595-Clock       
; 
;  
; Character map
;
;        abcdefghijklmn             abcdefghijklmn      aaaaaaaaa
;  ===============================================     ih   g   bc
;  0 0   abc-e---i-klm-      20 J   --c-e-----k-m-     i h  g  b c
;  1 1   -bc-e---------      21 K   -b---f--ijk---     i  h g b  c
;  2 2   a-cd-----jk-m-      22 L   --------i-k-m-     i   hgb   c
;  3 3   a-cde-------m-      23 M   -bc-e--hi-k---      jjjj dddd
;  4 4   --cde---ij----      24 N   --c-ef-hi-k---     k   lnf   e
;  5 5   a----f--ij--m-      25 O   a-c-e---i-k-m-     k  l n f  e
;  6 6   a--de---ijk-m-      26 P   a-cd----ijk---     k l  n  f e
;  7 7   ab-----------n      27 Q   a-c-ef--i-k-m-     kl   n   fe
;  8 8   a-cde---ijk-m-      28 R   a-cd-f--ijk---      mmmmmmmmm
;  9 9   a-cde---ij--m-      29 S   a--de---ij--m- 
; 10 sp  --------------      30 T   a-----g------n
; 11 A   a-cde---ijk---      31 U   --c-e---i-k-m-
; 12 B   a-cde-g-----mn      32 V   -b------i-kl--
; 13 C   a-------i-k-m-      33 W   --c-ef--i-kl--
; 14 D   a-c-e-g-----mn      34 X   -b---f-h---l--
; 15 E   a-------ijk-m-      35 Y   -b-----h-----n
; 16 F   a-------ijk---      36 Z   ab---------lm-  
; 17 G   a--de---i-k-m-      37 -   ---d-----j----
; 18 H   --cde---ijk---      38 +   ---d--g--j---n
; 19 I   a-----g-----mn      39 =   ---d-----j--m-
;
    
;*******************************************************************************
; Variables in shared memory
;*******************************************************************************
; CORE REGISTERS
;---------------
;    x00 INDF0      x04 FSR0L       x08 BSR
;    x01 INDF1      x05 FSR0H       x09 WREG
;    x02 PCL        x06 FSR1L       x0A PCLATH
;    x03 STATUS     x07 FSR1H       x0B INTCON

;-----------------------
    UDATA_SHR ; 16 bytes of shared/global memory area 
;-----------------------
dispbuf     res 8   ; Display buffer, holds values 0..39 for characters
tick        res 1   ; ISR Increments at 0.1 second rate
button      res 1   ; ISR The pressed button number 0..7, or 0xFF if no button
encoder     res 1   ; ISR Set to negatives or positives, must be 0'd by user
p           res 1   ; Generic p(ointer) variable
game        res 1   ; The select game number
cnt         res 1
round       res 1
decr16ms    res 1   ; ISR decrements at 16ms rate

;*******************************************************************************
; Variables in individual bank memories
;*******************************************************************************

;-----------------------
bank0 UDATA 0*0x80+0x20 ; Bank 0 PORT/TMRx
;-----------------------
iEncold     res 1       ; ISR Used to analyze movements of the rotary decoder
bin         res 1
ones        res 1       ; Used by Bin2Ascii
tens        res 1       ; Used by Bin2Ascii
length      res 1       ; Current sequence length
answer      res 1

;-----------------------
bank1 UDATA 1*0x80+0x20 ; Bank 1 TRIS/PIE/OPTION_REG/ADCCONx
;-----------------------
rndH        res 1       ; Random number
rndL        res 1
tmp         res 1       ; Temporary variable for random number generation

;-----------------------
bank2 UDATA 2*0x80+0x20 ; Bank 2 LAT/CMx/DAC
;-----------------------
seconds     res 1       ; ISR Counts up at 1 Hz
iSec10      res 1       ; ISR used for count 10 ten before seconds+1 
iCnt        res 1       ; ISR
iCh         res 1       ; ISR
iTick49     res 1       ; ISR Counts down from 49 to 0 keeping track of 100ms 
iDispno     res 1       ; ISR The number of the current display 0..7
iButton     res 1       ; ISR Collects buttons during full display scan

;-----------------------
bank3 UDATA 3*0x80+0x20 ; Bank3 ANSEL/PM/RC1/TX1
;-----------------------
guesses     res 4*20    ; Up to 20 guesses of 4 letters each

     
; Defines for compile #ifdef's     
#define CRACK   0 
#define TONES   1
#define ZEONE   1
#define SORTS   1

; Constants
#define DELAYFACTOR 16          ; The decrement tick is at 16ms rate
#define CHAROFFSET  54          ; @..Z must be offsetted to display correcly
#define SPACE       10
#define MINUS       37          ; Our "ascii" value for -
#define PLUS        38          ; Our "ascii" value for +
#define EQUAL       39          ; Out "ascii" value for =

; Hardware-related constants
#define ENCBUTTON   PORTA,2
#define ENCA        PORTC,1          
#define ENCB        PORTC,2          
#define BUTTON      PORTC,3          
#define LATCH595     LATA,4
#define DATA595      LATC,4 
#define CLOCK595     LATC,5
#define TRISLATCH   TRISA,4
#define TRISDATA    TRISC,4
#define TRISCLOCK   TRISC,5

;*******************************************************************************
; Reset & Interrupt Vectors
;*******************************************************************************

RES_VECT CODE 0x0000        ; Processor reset vector
    goto    Start           ; Jump to beginning of program

ISR CODE 0x0004             ; Interrupt vector 
    goto Timer0Interrupt    ; Jump to interrupt code

;------------------------------------------------------------------------------
; Lookup tables here near the start of code to avoid page wrapping
;------------------------------------------------------------------------------
GameNames:
    incf    p
    movfw   p
    brw
#if CRACK               ; Four letter word Mastermind game
    dt 'C'-CHAROFFSET
    dt 'R'-CHAROFFSET
    dt 'A'-CHAROFFSET
    dt 'C'-CHAROFFSET
    dt 'K'-CHAROFFSET 
#endif
#if TONES               ; Eight-button Simon
    dt 'T'-CHAROFFSET
    dt 'O'-CHAROFFSET
    dt 'N'-CHAROFFSET
    dt 'E'-CHAROFFSET
    dt 'S'-CHAROFFSET
#endif
#if ZEONE               ; Dec/Hex-to-Binary conversion game
    dt 'Z'-CHAROFFSET
    dt 'E'-CHAROFFSET
    dt 'O'-CHAROFFSET
    dt 'N'-CHAROFFSET
    dt 'E'-CHAROFFSET 
#endif
#if SORTS               ; Sort-the-letters
    dt 'S'-CHAROFFSET
    dt 'O'-CHAROFFSET
    dt 'R'-CHAROFFSET
    dt 'T'-CHAROFFSET
    dt 'S'-CHAROFFSET 
#endif
 
    dt  39,39,39,39,39   ; Filler since we don't have four games

;****************************************************************************
; Convert a bit number (0..7) to a mask value
;   Input: WREG
;   Destroys:  WREG
;   Banksel:  
;****************************************************************************
BitToMask:
    brw
    dt  1,2,4,8,16,32,64,128
    
;****************************************************************************
; Pulses the shiftregister clock signal low-high-low that will sample the
; current value of the data pin and shift all the existing bit one step
;   Input:     <none>
;   Destroys:  <none>
;   Banksel:   <none> But assumes bank 2 is already selected
;****************************************************************************
Pulse595Clock:
    bsf     CLOCK595    ;2; Toggle SHIFT_CLOCK
    nop
    bcf     CLOCK595    ;2;
    return

;****************************************************************************
; Pulses the shiftregister latch signal low-high-low that will cause the
; previosly sampled/shifted bits to appear at the output pins
;   Input:     <none>
;   Destroys:  <none>
;   Banksel:   <none> But assumes bank 2 is already selected
;****************************************************************************
Pulse595Latch:
    bsf     LATCH595    ;2; Toggle the LATCH pin now when all shift registers
    nop
    bcf     LATCH595    ;2; 
    return

;*******************************************************************************
; INTERRUPT CODE
;   Keeps track of the 0.1 second time ticker 
;   Reads the buttons
;   Pre-clears the display shift-registers to avoid ghosting
;   Shifts out the new SPI data to the display shift registers
;   Reads the quadrature encoder
;*******************************************************************************
Timer0Interrupt:
    bcf     INTCON,T0IF ;c; Clear the timer interrupt flag        

; Keep track of times
    banksel iTick49
    decfsz  iTick49     ;2; 49 ticks are 100.35ms, decrement and
    goto    not100ms    ; check if this counter reached 0, then...
    ; Here we have reached a 100ms point in time
    movlw   49          ; ...restart count from 49
    movwf   iTick49     ;2;
    incf    tick        ;c;  And increment the resettable 0.1s time keeper
    decfsz  iSec10      ;2; Also update the count-to-seconds counter
    goto    not100ms    ;   No more here is not reached 0
    movlw   10          ;   We have counted a full second, start over from 10
    movwf   iSec10      ;2;
    incf    seconds     ;2; Increment the game-time/score keeper
not100ms

; Update display pointer variables to point to next display
; also transfer local button into to global after full display scan
    incf    iDispno,W   ;2;  Select next display 
    andlw   0x07        ;   Wrap after the last display
    movwf   iDispno     ;2;
    btfss   STATUS,Z    ;c; At the first display?
    goto    NoButtonUpdate; Nope, carry on with the display
    movfw   iButton     ;2; Yes, transfer internal button state
    movwf   button      ;c; to the global, and clear the internal
    movlw   0xff        ;   in preparation for the next scans
    movwf   iButton     ;2;
    decf    decr16ms    ;c; Handle down counter here to keep code short
NoButtonUpdate

; The P-MOSFETs that are connected to the commons of the displays
; takes so long to turn off that a faint shadow of the previous display
; are visible.
KillDisplay
    movlw   D'48'       ;  48 bits of segment+display data 
    movwf   iCnt        ;2;
KD1    
    bcf     DATA595     ;2; The first 40 bits should be low,
    movfw   iCnt        ;   
    sublw   8           ;   and the last 8 bits should be high.
    btfsc   STATUS,C    
    bsf     DATA595
    call    Pulse595Clock ; Toggle the clock line
    decfsz  iCnt        ;2; Done all 48 bits yet?
    goto    KD1
    call    Pulse595Latch  ; Yes, latch the data onto the ports
    
; Now, send out the new real data for the currently active display
    movfw   iDispno     ;2;
    addlw   LOW(dispbuf) ;c; Index into the dispbuf
    movwf   FSR1L       ;c; and get the character to display
    clrf    FSR1H       ;c;
    movfw   INDF1       ;c;
    movwf   iCh         ;2;
    incf    iCh         ;2;

    movlw   D'40'       ; 40 bits of segment data 
    movwf   iCnt        ;2;
l40b    
    bsf     DATA595     ;2; Set SHIFT_DATA high if c-- is zero
    decfsz  iCh         ;2;  
    bcf     DATA595     ;2; 
    call    Pulse595Clock
    decfsz  iCnt        ;2;
    goto    l40b
    
    movfw   iDispno     ;2;
    movwf   iCh         ;2;
    incf    iCh         ;2;

    movlw   D'8'        ;   8 bits of segment data 
    movwf   iCnt        ;2;
l8  
    bcf     DATA595     ;2; Set SHIFT_DATA low if iCh-- is zero
    decfsz  iCh         ;2;  
    bsf     DATA595     ;2;
    call    Pulse595Clock
    decfsz  iCnt        ;2;
    goto    l8
    call    Pulse595Latch

; Read and analyze rotary encoder
    banksel PORTC
    lsrf    PORTC,W     ;0; Encoder A/B is bit 1/2 at PORTC, shift to bits 0/1
    andlw   b'00000011' ;   and mask the rest off
    xorwf   iEncold,W   ;0; same as last reading?
    bz      EncNoChange ;   yes, branch (no change), else
    xorwf   iEncold,W   ;0; restore encoder bits in W    
    rrf     iEncold,F   ;0; prep for B-old ^ A-new       
    xorwf   iEncold,F   ;0; ENCOLD bit 0 = direction     
    rrf     iEncold,F   ;0; now Carry bit = direction    
    movwf   iEncold     ;0; update ENCOLD (new BA bits)  
    xorlw   B'00000011' ;   At a detent position (BA = 11)?
    bnz     EncNoChange ;   if not then ignore reading  
    btfsc   STATUS,C    ;c; Direction is determined by carry, so update
    goto    cv
    incf    encoder     ;c;
    goto    EncNoChange
cv  decf    encoder     ;c;
EncNoChange
    
; Check for button press
    btfsc   BUTTON      ;0; Bit is clear if button is pressed
    goto    NoPress
    banksel iDispno
    movfw   iDispno     ;2; Copy to internal button if pressed
    movwf   iButton     ;2;
NoPress

    ; Just waste a random number before exiting the ISR
    call    Random
    retfie

;*******************************************************************************
; MAIN PROGRAM
;*******************************************************************************
    
MAIN_PROG CODE
    
Start:
; Setup peripheral registers in the PIC

;             +--------- SPLLEN Software PLL Enable bit
;             |+-------- IRCF3 Internal Oscillator Frequency Select
;             ||+------- IRCF2
;             |||+------ IRCF1
;             ||||+----- IRCF0
;             |||||+---- n/a
;             ||||||+--- SCS1 System Clock Select
;             |||||||+-- SCS0
;             ||||||||    
    movlw   B'11110000'     ; Internal 32MHz oscillator
    banksel OSCCON          
    movwf   OSCCON          ;1;
    movwf   rndH            ;1; Set non-zero value in the random seed
    
    bcf     TRISLATCH       ;1; Setup output pins
    bcf     TRISDATA        ;1;
    bcf     TRISCLOCK       ;1;

    banksel ANSELA
    clrf    ANSELA          ;3; All GPIOs are digital
    clrf    ANSELC          ;3;
    
;    Setup Timer0 to generate interrupts at about 488 Hz for refreshing
;    the displays at a relatively flicker-free 61 Hz.
;
;       fOsc/4      Prescale     8bit counter   8 displays 
;    32000000/4 -> 8000000/64 -> 125000/256 -> 488/8 -> 61 Hz Refresh 
   
;             +--------- WPUEN  Weak Pull-Up Enable
;             |+-------- INTEDG Interrupt Edge Select
;             ||+------- TMR0CS Timer0 Clock Source Select
;             |||+------ TMR0SE Timer0 Source Edge Select
;             ||||+----- PSA    Prescaler Assignment
;             |||||+---- PS2
;             ||||||+--- PS1
;             |||||||+-- PS0    Prescaler Rate Selec
;             ||||||||    
    movlw   B'00000101'
    banksel OPTION_REG
    movwf   OPTION_REG      

;             +--------- GIE    Global Interrupt Enable
;             |+-------- PEIE   Peripheral Interrupt Enable
;             ||+------- TMR0IE Timer0 Overflow Interrupt Enable
;             |||+------ INTE   INT External Interrupt Enable
;             ||||+----- IOCIE  Interrupt-on-Change Enable
;             |||||+---- TMR0IF Timer0 Overflow Interrupt Flag
;             ||||||+--- INTF   INT External Interrupt Flag
;             |||||||+-- IOCIF  Interrupt-on-Change Interrupt Flag
;             ||||||||    
    movlw   B'10100000'
    movwf   INTCON      ;c;
    
; The chip is setup correctly now, so let the user use
; the knob to select one of the four available games
Main:
    clrf    encoder     ;c; Prevent random encoder glitch after games
MainLoop:
    andlw   3           ;   Make sure game is in range 0..3
    movwf   game        ;c;
    
    call    ClearDisplay     ; Show the name of the selection
    call    ShowGameName    
    movlw   100/DELAYFACTOR ;Delay for a bit to reduce flicker
    call    DelayX16
    
    banksel PORTC
    btfss   ENCBUTTON   ;0; Did user click the button?
    goto    GameSelected;   Sure did, start the game

    movfw   encoder     ;c; If the user rotated the knob then
    addwf   game,W      ;c; change game accordingly
    clrf    encoder     ;c;

    goto     MainLoop

GameSelected:
    movlw   10           ;   Flash the selected game name for a while
    movwf   cnt         ;c;
GS1
    call    ShowGameName
    movlw   100/DELAYFACTOR
    call    DelayX16
    call    ClearDisplay
    movlw   100/DELAYFACTOR
    call    DelayX16
    decfsz  cnt         ;c;
    goto    GS1
    
    movfw   game        ;c; Jump to the selected game
    brw 
#if CRACK
    goto    GameCrack
#endif
#if TONES
    goto    GameTones
#endif
#if ZEONE
    goto    GameZeOne
#endif
#if SORTS
    goto    GameSorts
#endif

;****************************************************************************
; CRACK  Four letter word Mastermind game
;****************************************************************************
#if CRACK
GameCrack:
#endif

;****************************************************************************
; TONES  Eight-button Simon
;****************************************************************************
#if TONES
GameTones:
    movlw   39
    call    ClearDisplayW
    
    movlw   LOW(guesses);   Point Index to array of tones
    movwf   FSR0L       ;c;
    movlw   HIGH(guesses)
    movwf   FSR0H       ;c;
    movlw   20          ;   20 array entries to populate
    movwf   cnt         ;c;
GTgenerate
    call    Random      ;   Generate random number 0..7
    banksel rndH        
    movfw   rndH        ;1;
    andlw   7
    movwf   INDF0       ;c; Store in array
    incf    FSR0L
    decfsz  cnt         ;c;
    goto    GTgenerate

GTnewGame    
    movlw   1
    movwf   round
GTshowSequence
    clrf    p           ;c; Position in array to show
GTshowLoop
    call    ClearDisplay
    movlw   HIGH(guesses)
    movwf   FSR0H       ;c;
    movlw   LOW(guesses);   Point Index to array of tones
    addwf   p,W
    movwf   FSR0L       ;c;
    movfw   INDF0       ;  Get  tones[p]
    movwf   cnt         ;  Tuck tone away in cnt while preparing new index
    addlw   LOW(dispbuf)
    movwf   FSR0L       ;c;
    movlw   HIGH(dispbuf)
    movwf   FSR0H       ;c;
    movfw   cnt
    addlw   1           ; Make tones show as 1..7 (add 11 to get A..H)
    movwf   INDF0
    movlw   1000/DELAYFACTOR ; Delay for 1000 ms while showing the current tone
    call    DelayX16
    call    ClearDisplay
    movlw   200/DELAYFACTOR ; Delay for 200 ms while showing the current tone
    call    DelayX16
    incf    p
    movfw   p
    subwf   round,W
    btfss   STATUS, Z
    goto    GTshowLoop
; All of the current sequence so far is shown, now let the user repeat it
    clrf    p           ;c; Position in array to show
GTcopyloop
    call    ClearDisplay
    call    WaitKeyPress; Wait for button press

    movlw   HIGH(dispbuf);  Show what the player is pressing
    movwf   FSR0H       ;c;
    movfw   button
    addlw   LOW(dispbuf)
    movwf   FSR0L       ;c;
    movfw   button
    addlw   1
    movwf   INDF0
    
    movlw   HIGH(guesses)
    movwf   FSR0H       ;c;
    movlw   LOW(guesses);   Point Index to array of tones
    addwf   p,W
    movwf   FSR0L       ;c;
    movfw   INDF0       ;  Get  tones[p]

    subwf   button,W    ; Correct button/tone?
    btfsc   STATUS,Z
    goto    GTcorrect
    call    PlayFail
    movfw   round       ;c; Copy the rounds number -1 as the score
    banksel seconds
    movwf   seconds     ;2; seconds/score
    decf    seconds
    goto    ShowScore   ;   Show score and go back to main menu
    
    
GTcorrect
    call    WaitKeyRelease

    incf    p
    movfw   p
    subwf   round,W
    btfss   STATUS, Z
    goto    GTcopyloop
    call    PlayCorrect

    movlw   3000/DELAYFACTOR  ; At end of sequence delay for 3 seconds
    call    DelayX16
    incf    round
    goto    GTshowSequence
#endif
    
;****************************************************************************
; ZEONE  Decimal-to-Binary conversion game
; The Score is based on total number of seconds used to pass all 10 rounds
;****************************************************************************
#if ZEONE

ZeOneLength:
    brw
    dt  1,2,3,4,5,6,7,7

GameZeOne:
    call    ClearSeconds;   Used as the total score
    clrf    round       ;c; Start at round 0
ZeOneRoundLoop:
    movlw   8           ;   Check if we done all 10 rounds
    xorwf   round,W     ;c
    btfsc   STATUS,Z
    goto    ShowScore   ;   We're done. Show score and exit
    
    movfw   round       ;c; Fetch the round length
    incf    round       ;c; And already now increment to next round
    call    ZeOneLength
    banksel length   
    movwf   length
    banksel bin
    clrf    bin         ;; Collect <length> number of 1 bits in bin
NewRandom
    call    Random      ;  Get random number between 0..7
    movlw   0x07;
    banksel rndH
    andwf   rndH,W      ;1;
    call    BitToMask   ;   Convert bit number to bit mask
    banksel tmp         
    movwf   tmp         ;1; Store the bitmask for later use
    banksel bin
    andwf   bin,W       ;0; Check if bit is already set..
    btfss   STATUS,Z
    goto    NewRandom   ; ... if so go back for another random number
    banksel tmp
    movfw   tmp         ;1;
    banksel bin
    iorwf   bin         ;0; Set the bit
    banksel length
    decfsz  length      ;0; Go back for more while length is > 0
    goto    NewRandom   ; 
    
    ; When reached here all the required bits are set in the bin variable
    call    ClearDisplay
    banksel bin
    movfw   bin         ;0; Show the target value until
    call    Bin8toAscii ;   the first keypress
    call    WaitKeyPress

    banksel answer
    clrf    answer      ;0; Clear the answer variable and
    movlw   0           ;    put zeros in all displays
    call    ClearDisplayW

ZeOneInRoundLoop
    movfw   button      ;c; Update the answer variable
    sublw   7           ;   The bits needs to be in reverse order
    call    BitToMask   ;   Convert 0..7 to a bitmask
    banksel answer
    xorwf   answer,F    ;0; Toggle the bit in answer
ZeOneShowBits
    clrf    encoder
    banksel answer
    movfw   answer
    call    ToBinary    ;  Show the bits on the display
    call    WaitKeyRelease

WaitKeyOrRotate
    btfss   button,7        ;c; Else check for next disp-button to be pressed
    goto    ZeOneInRoundLoop
    movfw   encoder         ;c; If encoder is rotated then
    btfsc   STATUS,Z        ;c; show target and answer
    goto    WaitKeyOrRotate
   ; The user have turned the knob, check the answer and see what to do
    banksel answer
    movfw   answer          ;0; Is the answer correct?
    xorwf   bin,W
    btfsc   STATUS,Z
    goto    ZeOneCorrect    ;   Yes, it was correct

    ; If the answer is wrong then show both the target value
    ; and the answer for a few seconds and go back and let the user
    ; adjust his answer
    call    ClearDisplay   
    movfw   answer          ;0;
    call    Bin8toAscii
    call    CopyDisp3FirstTo3Last
    banksel bin
    movfw   bin
    call    Bin8toAscii

    movlw   3000/DELAYFACTOR ; Delay for 3 seconds as punishment
    call    DelayX16

    goto    ZeOneShowBits

ZeOneCorrect
    call    PlayCorrect
    goto    ZeOneRoundLoop

#endif
    
    
ShowScore;
    call    ClearDisplay
    banksel  seconds
    movfw   seconds     ;2;
    call    Bin8toAscii
    call    CopyDisp3FirstTo3Last
    movlw   'S'-CHAROFFSET
    movwf   dispbuf+0
    movlw   'C'-CHAROFFSET
    movwf   dispbuf+1
    movlw   'R'-CHAROFFSET
    movwf   dispbuf+2
    movlw   'E'-CHAROFFSET
    movwf   dispbuf+3
    call    WaitKeyPress
    goto    Main
    
    
    
;****************************************************************************
;****************************************************************************
PlayCorrect:
    movlw   PLUS          ;   Show +++ for Correct
    goto    PlayFail+1
;****************************************************************************
;****************************************************************************
PlayFail:
    movlw   MINUS          ;   Show --- for Fail
    call    ClearDisplayW
    movlw   1500/DELAYFACTOR ; Delay for 1.5 seconds as punishment
    goto    DelayX16      ; DelayX16 will do the return for us

;****************************************************************************
; SORTS  Sort-the-letters reversed
;****************************************************************************
#if SORTS
GameSorts:
    call    ClearSeconds;   Used as the total score
    movlw   5           ;   One game is 5 rounds
    movwf   round       ;c;
GSRoundLoop:
    call    ClearDisplay
    movlw   LOW(dispbuf);   Point Index to dispbuf
    movwf   FSR0L       ;c;
    clrf    FSR0H       ;c;
    movlw   8           ;   Eight displays to populate
    movwf   cnt         ;c;
GSort1
    call    Random
    banksel rndH
    movfw   rndH        ;1;
    andlw   31          ;   Mask number down to 0..31
    addlw   11          ;   Offset so number start at 'A'
    movwf   p           ;c; Store number in variable
    addlw   255-26-11+1 ;   Check if number > 'Z'
    btfsc   STATUS,C    ;c;
    goto    GSort1      ;   If so, then get a new random number

    ; Check if this random number already is in the table (dispbuf)
    movfw   p           ;c; p holds the new random number
    xorwf   dispbuf+0,W
    btfsc   STATUS,Z
    goto    GSort1      ;   Found it in the table, go net a new random number
    
    movfw   p           ;c; p holds the new random number
    xorwf   dispbuf+1,W
    btfsc   STATUS,Z
    goto    GSort1      ;   Found it in the table, go net a new random number
    
    movfw   p           ;c; p holds the new random number
    xorwf   dispbuf+2,W
    btfsc   STATUS,Z
    goto    GSort1      ;   Found it in the table, go net a new random number
    
    movfw   p           ;c; p holds the new random number
    xorwf   dispbuf+3,W
    btfsc   STATUS,Z
    goto    GSort1      ;   Found it in the table, go net a new random number
    
    movfw   p           ;c; p holds the new random number
    xorwf   dispbuf+4,W
    btfsc   STATUS,Z
    goto    GSort1      ;   Found it in the table, go net a new random number
    
    movfw   p           ;c; p holds the new random number
    xorwf   dispbuf+5,W
    btfsc   STATUS,Z
    goto    GSort1      ;   Found it in the table, go net a new random number
    
    movfw   p           ;c; p holds the new random number
    xorwf   dispbuf+6,W
    btfsc   STATUS,Z
    goto    GSort1      ;   Found it in the table, go net a new random number

    movfw   p           ;c; p holds the new random number
    xorwf   dispbuf+7,W
    btfsc   STATUS,Z
    goto    GSort1      ;   Found it in the table, go net a new random number

    movfw   p           ;c; We didn't find it, so so store the number 
    movwf   INDF0       ;c; the number in the table
    incf    FSR0L       ;c;
    decfsz  cnt         ;c; Have done them all yet?
    goto    GSort1      ;   No, go back and do more

    ; All 8 random number (letters) are in place in the dispbuf table
    ; let the game round begin
    movlw   8
    movwf   game        ;c; "game" is used to count the eight correct answers
GSLoop  
    call    WaitKeyPress ; Wait for user to selet a character
    
    movlw   8           ; Scan thru all 8 entries in table
    movwf   cnt
    movlw   LOW(dispbuf); Start at the first dispbuf
    movwf   FSR0L
    movfw   INDF0       ; Get the data for #0 and store in "p"
    movwf   p
GSTest
    movfw   p
    subwf   INDF0,W
    btfss   STATUS,C
    goto    smaller
    movfw   INDF0       ; Found new larges, copy the data
    movwf   p
smaller
    incf    FSR0L
    decfsz  cnt
    goto    GSTest

; By now we have the lowest data/value in "p"

    movlw   LOW(dispbuf); Get the value the user selected
    addwf   button,W
    movwf   FSR0L
    movfw   INDF0
    subwf   p,W         ;c; Check if it is the same
    btfsc   STATUS,Z
    goto    same
; Not same, so show minus for a while as punishment
    movfw   INDF0       ;c; Save the original character in p
    movwf   p           ;c;
    movlw   MINUS       ;   Put - in its place
    movwf   INDF0       ;c;
    movlw   3000/DELAYFACTOR
    call    DelayX16
    movfw   p           ;c; Restore the original character
    movwf   INDF0       ;c;
    goto    GSLoop

same
    movlw   SPACE       ; Clear the character at the place
    movwf   INDF0       ; 
    call    WaitKeyRelease

    decfsz  game        ;c; Have got all eight chars yet? 
    goto    GSLoop      ;   No, go back and continue this round
    
    decfsz  round       ;c; Played all rounds yet?
    goto    GSRoundLoop ;   No, go back and make&play a new round

    goto    ShowScore   ;   All rounds played, show score and exit
#endif

    
;****************************************************************************
; ToBinary - Shows WREG as a binary number on the display
;   Input:    WREG
;   Destroys: tmp, cnt, FSR0x
;   Banksel:  1
;****************************************************************************
ToBinary:
#if ZEONE
    banksel tmp
    movwf   tmp         ;1; Store data for shifting out bits
    movlw   LOW(dispbuf);   Point Index to dispbuf
    movwf   FSR0L       ;c;
    clrf    FSR0H       ;c;
    movlw   8           ;   Eight displays to handle
    movwf   cnt         ;c;
ToBin
    clrf    INDF0       ;c; Begin by setting display as "0"
    rlf     tmp         ;1; Shift out msb of data into Carry
    btfsc   STATUS,C    ;c; Was the MSB high?
    incf    INDF0       ;c; Yes, then set display as "1"
    incf    FSR0L       ;c; Point to next display
    decfsz  cnt         ;c; Loop back if done all displays done yet
    goto    ToBin
    return
#endif
    
   
;****************************************************************************
; ClearDisplay - Sets <space> characters in all displays
;   Input: <none>   
;   Destroys: WREG
;   Banksel:  <none>
; ClearDisplayW - Sets the character in WREG in all displays
;   Input: WREG   
;   Destroys: <none>
;   Banksel:  <none>
;****************************************************************************
ClearDisplay:
    movlw   '@'-CHAROFFSET
ClearDisplayW:
    movwf   dispbuf+0
    movwf   dispbuf+1
    movwf   dispbuf+2
    movwf   dispbuf+3
    movwf   dispbuf+4
    movwf   dispbuf+5
    movwf   dispbuf+6
    movwf   dispbuf+7
    return

;****************************************************************************
; ShowGameName - Shows the name of the game pointed to by <game>
;   Input:    game
;   Destroys: WREG, p
;   Banksel:  <none>
;****************************************************************************
ShowGameName:
    lslf    game,W      ;c; Multiply game number by 5 and put in p(ointer)
    movwf   p           ;c;
    lslf    p           ;c;
    movfw   game        ;c;
    addwf   p           ;c;
    
    decf    p           ;c; Backup one step since GameNames autoincrements
    call    GameNames
    movwf   dispbuf+0   ;c;
    call    GameNames
    movwf   dispbuf+1   ;c;
    call    GameNames
    movwf   dispbuf+2   ;c;
    call    GameNames
    movwf   dispbuf+3   ;c;
    call    GameNames
    movwf   dispbuf+4   ;c;
    return

;****************************************************************************
; Random - 16 bit random number generator
;   Input: <none>
;   Destroys: WREG, tmp
;   Banksel:  1
;****************************************************************************
Random:
    banksel rndH
    rrf     rndH,W      ;1; Wreg = Q12
	xorwf	rndL,W      ;1; Wreg = xor(Q12,Q3)
	movwf	tmp         ;1; tmp(bit3) = xor(Q12,Q3)
	swapf	tmp         ;1; tmp(bit7) = xor(Q12,Q3)
	rlf     rndH        ;1; Wreg = Q14
	xorwf	rndH        ;1; Wreg = xor(Q15,Q14)
	xorwf	tmp 		;1; tmp(bit7) = xor(Q15,Q14,Q12,Q3)
	rlf     tmp,W		;1; cflag = xor(Q15,Q14,Q12,Q3)
	rlf     rndL        ;1; move bit7 to new bit0 and then..
	rlf     rndH        ;1; ..rotate RNG value to the left
    return
    
    
;****************************************************************************
; Bin8toAscii - Convert WREG into 3-digit number at dispbuf[0..2]
;   Input: WREG
;   Destroys: WREG, ones,tens
;   Banksel:  1
;****************************************************************************
Bin8toAscii:
#if ZEONE
    banksel tens
    clrf    tens            ;0;
    decf    tens,F          ;0; Preset 'tens' to -1
div10
    movwf   ones            ;0;
    incf    tens,F          ;0; bump 'tens', 0x00..0x25
    movlw   6               ;   using "packed bcd" format
    addwf   tens,W          ;0; bcd "digit carry"?
    skpndc                  ;   no, skip, else
    movwf   tens            ;0; fix 'tens'
    movlw   10              ;   ones = ones - 10
    subwf   ones,W          ;0; borrow?
    bc      div10           ;   no, branch, else
    movfw   ones            ;0;
    movwf   dispbuf+2       ;c;
    movfw   tens            ;0;
    movwf   dispbuf+0       ;c;
    swapf   dispbuf+0       ;c;
    movwf   dispbuf+1       ;c;
    movlw   0x0F        
    andwf   dispbuf+1       ;c;
    andwf   dispbuf+0       ;c;
    return
#endif

#if ZEONE
CopyDisp3FirstTo3Last:
    movfw   dispbuf+0
    movwf   dispbuf+5
    movfw   dispbuf+1
    movwf   dispbuf+6
    movfw   dispbuf+2
    movwf   dispbuf+7
    return
#endif
    
;****************************************************************************
; Loop until one of the eight buttons are pressed. Then exit
; after a short debounceing delay
;   Input: <none>
;   Destroys:  <none>
;   Banksel:  <none>
;****************************************************************************
WaitKeyPress:
    btfsc   button,7        ;c; Loop until button pressed
    goto    WaitKeyPress
    goto    WKDebounce      ;   Debounce and return

;****************************************************************************
; Loop until all of the eight buttons are released. Then exit
; after a short debounceing delay
;   Input: <none>
;   Destroys:  <none>
;   Banksel:  <none>
;****************************************************************************
WaitKeyRelease:
    btfss   button,7        ;c; Loop until buttons released
    goto    WaitKeyRelease
; Fall through to the setup of the Debounce delay, then just fall through to
; the delay function thet will return to the caller for us
WKDebounce:
    movlw   2

;****************************************************************************
; Delay the specified number of 16ms units
; The slighly strange value of 16 ms is because we can 
; decrementing this timing variable in the ISR at the same time
; we're handling the button testing at the end of each full
; update of the display.
;   Input: WREG
;   Destroys: <none>
;   Banksel:  <none>
;****************************************************************************
DelayX16:
    movwf   decr16ms
DelayX16Loop
    TSTF    decr16ms
    BNZ     DelayX16Loop
    return

;****************************************************************************
;   Input: <none<
;   Destroys: WREG
;   Banksel:  2
;****************************************************************************
ClearSeconds:
    banksel iSec10
    movlw   10
    movwf   iSec10      ;2;
    clrf    seconds     ;2;
    return
    
    END