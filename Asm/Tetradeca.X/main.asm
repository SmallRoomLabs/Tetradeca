;-----------------------------------------------------------------------------
; Tetradeca - A multi-game unit using 14 segment LED displays and a PIC16F1705
;-----------------------------------------------------------------------------
;
; The files for the full project are located at 
; github.com/SmallRoomLabs/Tetradeca
;
; Copyright (c) 2016 Mats Engstrom SmallRoomLabs
; Released under the MIT license
;
; This project is an entry for the Hackaday 1kB Competition:
; hackaday.io/contest/18215-the-1kb-challenge    
; The size of the code and data tables are limited to 1024 bytes in total. 
; Since the PIC16-series is a 14 bit code architecture so the 1024 bytes only
; allows for 1024*8/14=585 "words"
;
; Game ideas:
;  * CRACK  Four letter word Mastermind game
;  * TONES  Eight-button Simon
;  * ZEONE  Decimal-to-Binary conversion game
;  * SORTS  Sort-the-letters
;
; Credits and acknowledgements - I've used code from the sources below. I
; didn't find any license information for them, but I boldly assume they are
; released into the public domain, one being generated by an online tool, the
; other being published by the awesome Mike McLaren in multiple forums when
; replying to people asking about quadrature encoders. 
;  
;   * piclist.com/techref/piclist/codegen/delay.htm for the delay subroutine
;   * Mike McLaren K8LH for the Quadrature Encoder decoder snippet 
;   * Microchip AN544 for the Random number generator
;
; Some general PIC tips & tricks pages that came to good use:
;   * picprojects.org.uk/projects/pictips.htm
;

    RADIX DEC           ; Use decimal numbers by default
    ERRORLEVEL -302     ; Kill messages about "Register not in bank 0"
    ERRORLEVEL -305     ; Kill messages about "Using default destination"

    #include "p16f1705.inc"
 
    __CONFIG _CONFIG1, _FOSC_INTOSC & _WDTE_OFF & _PWRTE_OFF & _MCLRE_ON & _CP_OFF & _BOREN_OFF & _CLKOUTEN_OFF & _IESO_OFF & _FCMEN_OFF
    __CONFIG _CONFIG2, _WRT_OFF & _PPS1WAY_OFF & _ZCDDIS_ON & _PLLEN_ON & _STVREN_ON & _BORV_LO & _LPBOR_OFF & _LVP_ON

#define CRACK   1 
#define TONES   1
#define ZEONE   1
#define SORTS   1

;
;  A0 in  ICSPDAT               16F1705                 '595
;  A1 in  ICSPCLK               +--v--+                +--v--+
;  A2 in  Rotary-Button       - |1  14| +            QB|1  16| +
;  A3 in  ICSPRES            A5 |2  13| RA0/ISPDAT   QC|2  15| QA
;  A4 out 595-Latch          A4 |3  12| RA1/ISPCLK   QD|3  14| SerIn
;  A5 in  <unused>       RES/A3 |4  11| RA2          QE|4  13| /OE
;  C0 in  <unused>           C5 |5  10| C0           QF|5  12| LATCH
;  C1 in  Rotary-A           C4 |6   9| C1           QG|6  11| CLOCK
;  C2 in  Rotary-B           C3 |7   8| C2           QH|7  10| /CLEAR
;  C3 in  Buttons               +-----+              - |8   9| SerOut
;  C4 out 595-DataIn                                  +-----+
;  C5 out 595-Clock       
; 
;  
; Character map
;
;        abcdefghijklmn             abcdefghijklmn      aaaaaaaaa
;  ===============================================     ih   g   bc
;  0 0   abc-e---i-klm-      20 J   --c-e-----k-m-     i h  g  b c
;  1 1   -bc-e---------      21 K   -b---f--ijk---     i  h g b  c
;  2 2   a-cd-----jk-m-      22 L   --------i-k-m-     i   hgb   c
;  3 3   a-cde-------m-      23 M   -bc-e--hi-k---      jjjj dddd
;  4 4   --cde---ij----      24 N   --c-ef-hi-k---     k   lnf   e
;  5 5   a----f--ij--m-      25 O   a-c-e---i-k-m-     k  l n f  e
;  6 6   a--de---ijk-m-      26 P   a-cd----ijk---     k l  n  f e
;  7 7   ab-----------n      27 Q   a-c-ef--i-k-m-     kl   n   fe
;  8 8   a-cde---ijk-m-      28 R   a-cd-f--ijk---      mmmmmmmmm
;  9 9   a-cde---ij--m-      29 S   a--de---ij--m- 
; 10 sp  --------------      30 T   a-----g------n
; 11 A   a-cde---ijk---      31 U   --c-e---i-k-m-
; 12 B   a-cde-g-----mn      32 V   -b------i-kl--
; 13 C   a-------i-k-m-      33 W   --c-ef--i-kl--
; 14 D   a-c-e-g-----mn      34 X   -b---f-h---l--
; 15 E   a-------ijk-m-      35 Y   -b-----h-----n
; 16 F   a-------ijk---      36 Z   ab---------lm-  
; 17 G   a--de---i-k-m-      37 -   ---d-----j----
; 18 H   --cde---ijk---      38 +   ---d--g--j---n
; 19 I   a-----g-----mn      39 =   ---d-----j--m-
;
    
;*******************************************************************************
; Variables in shared memory
;*******************************************************************************
; CORE REGISTERS
;---------------
;    x00 INDF0      x04 FSR0L       x08 BSR
;    x01 INDF1      x05 FSR0H       x09 WREG
;    x02 PCL        x06 FSR1L       x0A PCLATH
;    x03 STATUS     x07 FSR1H       x0B INTCON

;-----------------------
    UDATA_SHR ; 16 bytes of shared/global memory area 
;-----------------------
dispbuf     res 8   ; Display buffer, holds values 0..39 for characters
tick        res 1   ; ISR Increments at 0.1 second rate
button      res 1   ; ISR The pressed button number 0..7, or 0xFF if no button
encoder     res 1   ; ISR Set to negatives or positives, must be 0'd by user
p           res 1   ; Generic p(ointer) variable
game        res 1   ; The select game number
cnt         res 1
round       res 1         
;*******************************************************************************
; Variables in individual bank memories
;*******************************************************************************

;-----------------------
bank0 UDATA 0*0x80+0x20 ; Bank 0 PORT/TMRx
;-----------------------
iEncold     res 1       ; ISR Used to analyze movements of the rotary decoder
bin         res 1
ones        res 1       ; Used by Bin2Ascii
tens        res 1       ; Used by Bin2Ascii
length      res 1       ; Current sequence length
answer      res 1

;-----------------------
bank1 UDATA 1*0x80+0x20 ; Bank 1 TRIS/PIE/OPTION_REG/ADCCONx
;-----------------------
rndH        res 1       ; Random number
rndL        res 1
tmp         res 1       ; Temporary variable for random number generation

;-----------------------
bank2 UDATA 2*0x80+0x20 ; Bank 2 LAT/CMx/DAC
;-----------------------
seconds     res 1
iCnt        res 1       ; ISR
iCh         res 1       ; ISR
iTick49     res 1       ; ISR Counts down from 49 to 0 keeping track of 100ms 
iDispno     res 1       ; ISR The number of the current display 0..7
dly1        res 1
dly2        res 1
dly3        res 1
iButton     res 1       ; ISR Collects buttons during full display scan

;-----------------------
bank3 UDATA 3*0x80+0x20 ; Bank3 ANSEL/PM/RC1/TX1
;-----------------------
guesses     res 4*20    ; Up to 20 guesses of 4 letters each
        

    
#define ENCBUTTON   PORTA,2
#define ENCA        PORTC,1          
#define ENCB        PORTC,2          
#define BUTTON      PORTC,3          
#define LATCH595     LATA,4
#define DATA595      LATC,4 
#define CLOCK595     LATC,5
#define TRISLATCH   TRISA,4
#define TRISDATA    TRISC,4
#define TRISCLOCK   TRISC,5

;*******************************************************************************
; Reset & Interrupt Vectors
;*******************************************************************************

RES_VECT CODE 0x0000        ; Processor reset vector
    goto    Start           ; Jump to beginning of program

ISR CODE 0x0004             ; Interrupt vector 
    goto Timer0Interrupt    ; Jump to interrupt code

;------------------------------------------------------------------------------
; Lookup tables here near the start of code to avoid page wrapping
;------------------------------------------------------------------------------
GameNames:
    incf    p
    movfw   p
    brw
#if CRACK
    dt 'C'-54,'R'-54,'A'-54,'C'-54,'K'-54 ; Four letter word Mastermind game
#endif
#if TONES
    dt 'T'-54,'O'-54,'N'-54,'E'-54,'S'-54 ; Eight-button Simon
#endif
#if ZEONE
    dt 'Z'-54,'E'-54,'O'-54,'N'-54,'E'-54 ; Dec/Hex-to-Binary conversion game
#endif
#if SORTS
    dt 'S'-54,'O'-54,'R'-54,'T'-54,'S'-54 ; Sort-the-letters
#endif


BitToMask:
    brw
    dt  1,2,4,8,16,32,64,128
    
 
;*******************************************************************************
; INTERRUPT CODE
;   Keeps track of the 0.1 second time ticker 
;   Shifts out the SPI data to the display shift registers
;   Reads the buttons
;   Reads the quadrature encoder
;*******************************************************************************
Timer0Interrupt:
    bcf     INTCON,T0IF ;c; Clear the timer interrupt flag        

; Keep track of time
    banksel iTick49
    decfsz  iTick49     ;2; 49 ticks are 100.35ms, decrement and
    goto    not100ms    ; check if this counter reached 0, then...
    movlw   49          ; ...restart count from 49
    movwf   iTick49     ;2;
    incf    tick        ;c;  And increment the 0.1s time keeper
not100ms

; Update display pointer variables to point to next display
; also transfer local button into to global after full display scan
    incf    iDispno,W   ;2;  Select next display 
    andlw   0x07        ;   Wrap after the last display
    movwf   iDispno     ;2;
    btfss   STATUS,Z    ;c; At the first display?
    goto    NoButtonUpdate; Nope, carry on with the display
    movfw   iButton     ;2; Yes, transfer internal button state
    movwf   button      ;c; to the global, and clear the internal
    movlw   0xff        ;   in preparation for the next scans
    movwf   iButton     ;2;
NoButtonUpdate

; Send out data for the currently active display
    movfw   iDispno     ;2;
    addlw   LOW(dispbuf) ;c; Index into the dispbuf
    movwf   FSR1L       ;c; and get the character to display
    clrf    FSR1H       ;c;
    movfw   INDF1       ;c;
    movwf   iCh         ;2;
    incf    iCh         ;2;

    movlw   D'40'       ; 40 bits of segment data 
    movwf   iCnt        ;2;
l40b    
    bsf     DATA595     ;2; Set SHIFT_DATA high if c-- is zero
    decfsz  iCh         ;2;  
    bcf     DATA595     ;2; 
    nop
    bsf     CLOCK595    ;2; Toggle SHIFT_CLOCK
    nop
    bcf     CLOCK595    ;2;
    decfsz  iCnt        ;2;
    goto    l40b
    
;    banksel iDispno
    movfw   iDispno     ;2;
;    banksel LATC
    movwf   iCh         ;2;
    incf    iCh         ;2;
    movlw   D'8'        ;   8 bits of segment data 
    movwf   iCnt        ;2;
l8  
    bcf     DATA595     ;2; Set SHIFT_DATA low if iCh-- is zero
    decfsz  iCh         ;2;  
    bsf     DATA595     ;2;
    nop
    bsf     CLOCK595    ;2; Toggle SHIFT_CLOCK
    nop
    bcf     CLOCK595    ;2;
    decfsz  iCnt        ;2;
    goto    l8

    bsf     LATCH595    ;2; Toggle the LATCH pin now when all shift registers
    nop
    bcf     LATCH595    ;2; 


; Read and analyze rotary encoder
    banksel PORTC
    lsrf    PORTC,W     ;0; Encoder A/B is bit 1/2 at PORTC, shift to bits 0/1
    andlw   b'00000011' ;   and mask the rest off
    xorwf   iEncold,W   ;0; same as last reading?
    bz      EncNoChange ;   yes, branch (no change), else
    xorwf   iEncold,W   ;0; restore encoder bits in W    
    rrf     iEncold,F   ;0; prep for B-old ^ A-new       
    xorwf   iEncold,F   ;0; ENCOLD bit 0 = direction     
    rrf     iEncold,F   ;0; now Carry bit = direction    
    movwf   iEncold     ;0; update ENCOLD (new BA bits)  
    xorlw   B'00000011' ;   At a detent position (BA = 11)?
    bnz     EncNoChange ;   if not then ignore reading  
    btfsc   STATUS,C    ;c; Direction is determined by carry, so update
    goto    cv
    incf    encoder     ;c;
    goto    EncNoChange
cv  decf    encoder     ;c;
EncNoChange
    
; Check for button press
    btfsc   BUTTON      ;0; Bit is clear if button is pressed
    goto    NoPress
    banksel iDispno
    movfw   iDispno     ;2; Copy to internal button if pressed
    movwf   iButton     ;2;
NoPress

    ; Just waste a random number before exiting the ISR
    call    Random
    retfie

;*******************************************************************************
; MAIN PROGRAM
;*******************************************************************************
    
MAIN_PROG CODE
    
Start:
; Setup peripheral registers in the PIC

;             +--------- SPLLEN Software PLL Enable bit
;             |+-------- IRCF3 Internal Oscillator Frequency Select
;             ||+------- IRCF2
;             |||+------ IRCF1
;             ||||+----- IRCF0
;             |||||+---- n/a
;             ||||||+--- SCS1 System Clock Select
;             |||||||+-- SCS0
;             ||||||||    
    movlw   B'11110000'     ; Internal 32MHz oscillator
    banksel OSCCON          
    movwf   OSCCON          ;1;
    movwf   rndH            ;1; Set non-zero value in the random seed
    
    bcf     TRISLATCH       ;1; Setup output pins
    bcf     TRISDATA        ;1;
    bcf     TRISCLOCK       ;1;

    banksel ANSELA
    clrf    ANSELA          ;3; All GPIOs are digital
    clrf    ANSELC          ;3;
    
;    Setup Timer0 to generate interrupts at about 488 Hz for refreshing
;    the displays at a relatively flicker-free 61 Hz.
;
;       fOsc/4      Prescale     8bit counter   8 displays 
;    32000000/4 -> 8000000/64 -> 125000/256 -> 488/8 -> 61 Hz Refresh 
   
;             +--------- WPUEN  Weak Pull-Up Enable
;             |+-------- INTEDG Interrupt Edge Select
;             ||+------- TMR0CS Timer0 Clock Source Select
;             |||+------ TMR0SE Timer0 Source Edge Select
;             ||||+----- PSA    Prescaler Assignment
;             |||||+---- PS2
;             ||||||+--- PS1
;             |||||||+-- PS0    Prescaler Rate Selec
;             ||||||||    
    movlw   B'00000101'
    banksel OPTION_REG
    movwf   OPTION_REG      

;             +--------- GIE    Global Interrupt Enable
;             |+-------- PEIE   Peripheral Interrupt Enable
;             ||+------- TMR0IE Timer0 Overflow Interrupt Enable
;             |||+------ INTE   INT External Interrupt Enable
;             ||||+----- IOCIE  Interrupt-on-Change Enable
;             |||||+---- TMR0IF Timer0 Overflow Interrupt Flag
;             ||||||+--- INTF   INT External Interrupt Flag
;             |||||||+-- IOCIF  Interrupt-on-Change Interrupt Flag
;             ||||||||    
    movlw   B'10100000'
    movwf   INTCON      ;c;
    
; The chip is setup correctly now, so let the user use
; the knob to select one of the four available games
MainLoop:
    andlw   3           ;   Make sure game is in range 0..3
    movwf   game        ;c;
    
    call    ClearDisplay;   Show the name of the selection
    call    ShowGameName
    call    Delay10ms   ;   Delay for a bit to reduce flickering
    
    banksel PORTC
    btfss   ENCBUTTON   ;0; Did user click the button?
    goto    GameSelected;   Sure did, start the game

    movfw   encoder     ;c; If the user rotated the knob then
    addwf   game,W      ;c; change game accordingly
    clrf    encoder     ;c;

    goto     MainLoop

GameSelected:
    movlw   50           ;   Flash the selected game name for a while
    movwf   cnt         ;c;
GS1
    call    ShowGameName
    call    Delay10ms   
    call    ClearDisplay
    call    Delay10ms   
    decfsz  cnt         ;c;
    goto    GS1
    
    movfw   game        ;c; Jump to the selected game
    brw 
#if CRACK
    goto    GameCrack
#endif
#if TONES
    goto    GameTones
#endif
#if ZEONE
    goto    GameZeOne
#endif
#if SORTS
    goto    GameSorts
#endif

;****************************************************************************
; CRACK  Four letter word Mastermind game
;****************************************************************************
#if CRACK
GameCrack:
#endif

;****************************************************************************
; TONES  Eight-button Simon
;****************************************************************************
#if TONES
GameTones:
#endif
    
;****************************************************************************
; ZEONE  Decimal-to-Binary conversion game
;****************************************************************************
#if ZEONE

ZeOneLength:
    brw
    dt  2,2,3,3,3,4,4,4,5,5

GameZeOne:
    clrf    round       ;c; Start at round 0
ZeOneRoundLoop:
    movlw   10          ;   Check if we done all 10 rounds
    xorwf   round,W     ;c
    btfsc   STATUS,Z
    goto    ZeOneShowScore 
    movfw   round       ;c; Fetch the round length
    incf    round       ;c; And already now increment to next round
    call    ZeOneLength
    banksel length   
    movwf   length
    banksel bin
    clrf    bin         ;; Collect <length> number of 1 bits in bin
NewRandom
    call    Random      ;  Get random number between 0..7
    movlw   0x07;
    banksel rndH
    andwf   rndH,W      ;1;
    call    BitToMask   ;   Convert bit number to bit mask
    banksel tmp         
    movwf   tmp         ;1; Store the bitmask for later use
    banksel bin
    andwf   bin,W       ;0; Check if bit is already set..
    btfss   STATUS,Z
    goto    NewRandom   ; ... if so go back for another random number
    banksel tmp
    movfw   tmp         ;1;
    banksel bin
    iorwf   bin         ;0; Set the bit
    banksel length
    decfsz  length      ;0; Go back for more while length is > 0
    goto    NewRandom   ; 
    
    ; When reached here all the required bits are set in the bin variable
    call    ClearDisplay
    banksel bin
    movfw   bin         ;0; Show the target value until
    call    Bin8toAscii ;   the first keypress
    call    WaitKeyPress

    banksel answer
    clrf    answer      ;0; Clear the answer variable and
    movlw   0           ;    put zeros in all displays
    call    ClearDisplayW

ZeOneInRoundLoop
    movfw   button      ;c; Update the answer variable
    sublw   7           ;   The bits needs to be in reverse order
    call    BitToMask   ;   Convert 0..7 to a bitmask
    banksel answer
    xorwf   answer,F    ;0; Toggle the bit in answer
ZeOneShowBits
    clrf    encoder
    banksel answer
    movfw   answer
    call    ToBinary    ;  Show the bits on the display
    call    WaitKeyRelease

WaitKeyOrRotate
    btfss   button,7        ;c; Else check for next disp-button to be pressed
    goto    ZeOneInRoundLoop
    movfw   encoder         ;c; If encoder is rotated then
    btfsc   STATUS,Z        ;c; show target and answer
    goto    WaitKeyOrRotate
   ; The user have turned the knob, check the answer and see what to do
    banksel answer
    movfw   answer          ;0; Is the answer correct?
    xorwf   bin,W
    btfsc   STATUS,Z
    goto    ZeOneCorrect    ;   Yes, it was correct

    ; If the answer is wrong then show both the target value
    ; and the answer for a few seconds and go back and let the user
    ; adjust his answer
    call    ClearDisplay   
    movfw   answer          ;0;
    call    Bin8toAscii
    call    CopyDisp3FirstTo3Last
    banksel bin
    movfw   bin
    call    Bin8toAscii

    clrf    tick            ;c; Delay for 3 seconds
    btfss   tick,5
    goto    $-1

    goto    ZeOneShowBits

ZeOneCorrect
    call    PlayCorrect
    goto    ZeOneRoundLoop

ZeOneShowScore
    goto    MainLoop
    
    #endif

PlayCorrect:
    movlw   38          ;   Show +++ for Correct
    goto    PlayFail+1
PlayFail:
    movlw   37          ;   Show --- for Fail
    call    ClearDisplayW
    clrf    tick        ;c; Delay for 1.5 seconds
    btfss   tick,4
    goto    $-1
    return

;****************************************************************************
; SORTS  Sort-the-letters
;****************************************************************************
#if SORTS
GameSorts:
    call    ClearDisplay
    movlw   LOW(dispbuf);   Point Index to dispbuf
    movwf   FSR0L       ;c;
    clrf    FSR0H       ;c;
    movlw   8           ;   Eight displays to populate
    movwf   cnt         ;c;
GSort1
    call    Random
    banksel rndH
    movfw   rndH        ;1;
    andlw   31          ;   Mask number down to 0..31
    addlw   11          ;   Offset so number start at 'A'
    movwf   p           ;c; Store number in variable
    addlw   255-26-11+1 ;   Check if number > 'Z'
    btfsc   STATUS,C    ;c;
    goto    GSort1      ;   If so, then get a new random number

    movfw   p           ;c;
    xorwf   dispbuf+0,W
    btfsc   STATUS,Z
    goto    GSort1
    movfw   p           ;c;
    xorwf   dispbuf+1,W
    btfsc   STATUS,Z
    goto    GSort1
    movfw   p           ;c;
    xorwf   dispbuf+2,W
    btfsc   STATUS,Z
    goto    GSort1
    movfw   p           ;c;
    xorwf   dispbuf+3,W
    btfsc   STATUS,Z
    goto    GSort1
    movfw   p           ;c;
    xorwf   dispbuf+4,W
    btfsc   STATUS,Z
    goto    GSort1
    movfw   p           ;c;
    xorwf   dispbuf+5,W
    btfsc   STATUS,Z
    goto    GSort1
    movfw   p           ;c;
    xorwf   dispbuf+6,W
    btfsc   STATUS,Z
    goto    GSort1
    movfw   p           ;c;
    xorwf   dispbuf+7,W
    btfsc   STATUS,Z
    goto    GSort1

    movfw   p           ;c;
    movwf   INDF0
    incf    FSR0L
    decfsz  cnt         ;c;
    goto    GSort1

    call    WaitKeyPress
    call    WaitKeyRelease
    goto    GameSorts
#endif

    
;****************************************************************************
; ToBinary - Shows WREG as abinary number on the display
;   Input:    WREG
;   Destroys: tmp, cnt, FSR0
;   Banksel:  1
;****************************************************************************
ToBinary:
#if ZEONE
    banksel tmp
    movwf   tmp         ;1; Store data for shifting out bits
    movlw   LOW(dispbuf);   Point Index to dispbuf
    movwf   FSR0L       ;c;
    clrf    FSR0H       ;c;
    movlw   8           ;   Eight displays to handle
    movwf   cnt         ;c;
ToBin
    clrf    INDF0       ;c; Begin by setting display as "0"
    rlf     tmp         ;1; Shift out msb of data into Carry
    btfsc   STATUS,C    ;c; Was the MSB high?
    incf    INDF0       ;c; Yes, then set display as "1"
    incf    FSR0L       ;c; Point to next display
    decfsz  cnt         ;c; Loop back if done all displays done yet
    goto    ToBin
    return
#endif
    
;****************************************************************************
; Delay100ms - Delays for 100ms
;   Input:    
;   Destroys: dly1,dly2,dly3
;   Banksel:  2
;****************************************************************************
Delay100ms:
    banksel dly1
	movlw	0x6C
	movwf	dly1        ;2;
	movlw	0xBF
	movwf	dly2        ;2;
	movlw	0x02
	movwf	dly3        ;2;
Delay100ms_0
	decfsz	dly1        ;2;
	goto	$+2
	decfsz	dly2        ;2;
	goto	$+2
	decfsz	dly3        ;2;
	goto	Delay100ms_0
    return

;****************************************************************************
; Delay10ms - Delays for 10ms
;   Input:    
;   Destroys: dly1,dly2
;   Banksel:  2
;****************************************************************************
Delay10ms:
    banksel dly1
	movlw	0x7E
	movwf	dly1        ;2;
	movlw	0x3F
	movwf	dly2        ;2;
Delay10ms_0
	decfsz	dly1        ;2;
	goto	$+2
	decfsz	dly2        ;2;
	goto	Delay10ms_0
	return
    
    
;****************************************************************************
; ClearDisplay - Sets <space> characters in all displays
; ClearDisplayW - Sets the character in WREG in all displays
;   Input: <none>/WREG   
;   Destroys: WREG/<none>
;   Banksel:  <none>
;****************************************************************************
ClearDisplay:
    movlw   '@'-54
ClearDisplayW:
    movwf   dispbuf+0
    movwf   dispbuf+1
    movwf   dispbuf+2
    movwf   dispbuf+3
    movwf   dispbuf+4
    movwf   dispbuf+5
    movwf   dispbuf+6
    movwf   dispbuf+7
    return

;****************************************************************************
; ShowGameName - Shows the name of the game pointed to by <game>
;   Input:    game
;   Destroys: p
;   Banksel:  <none>
;****************************************************************************
ShowGameName:
    lslf    game,W      ;c; Multiply game number by 5 and put in p(ointer)
    movwf   p           ;c;
    lslf    p           ;c;
    movfw   game        ;c;
    addwf   p           ;c;
    
    decf    p           ;c; Backup one step since GameNames autoincrements
    call    GameNames
    movwf   dispbuf+0   ;c;
    call    GameNames
    movwf   dispbuf+1   ;c;
    call    GameNames
    movwf   dispbuf+2   ;c;
    call    GameNames
    movwf   dispbuf+3   ;c;
    call    GameNames
    movwf   dispbuf+4   ;c;
    return

;****************************************************************************
; Random - 16 bit random number generator
;   Input: <none>
;   Destroys: tmp
;   Banksel:  1
;****************************************************************************
Random:
    banksel rndH
    rrf     rndH,w      ;1; Wreg = Q12
	xorwf	rndL,W      ;1; Wreg = xor(Q12,Q3)
	movwf	tmp         ;1; tmp(bit3) = xor(Q12,Q3)
	swapf	tmp         ;1; tmp(bit7) = xor(Q12,Q3)
	rlf     rndH        ;1; Wreg = Q14
	xorwf	rndH        ;1; Wreg = xor(Q15,Q14)
	xorwf	tmp 		;1; tmp(bit7) = xor(Q15,Q14,Q12,Q3)
	rlf     tmp,W		;1; cflag = xor(Q15,Q14,Q12,Q3)
	rlf     rndL        ;1; move bit7 to new bit0 and then..
	rlf     rndH        ;1; ..rotate RNG value to the left
    return
    
    
;****************************************************************************
; Bin8toAscii - Convert WREG into 3-digit number at dispbuf[0..2]
;   Input: WREG
;   Destroys: ones,tens
;   Banksel:  1
;****************************************************************************
Bin8toAscii:
#if ZEONE
    banksel tens
    clrf    tens            ;0;
    decf    tens,F          ;0; Preset 'tens' to -1
div10
    movwf   ones            ;0;
    incf    tens,F          ;0; bump 'tens', 0x00..0x25
    movlw   6               ;   using "packed bcd" format
    addwf   tens,W          ;0; bcd "digit carry"?
    skpndc                  ;   no, skip, else
    movwf   tens            ;0; fix 'tens'
    movlw   10              ;   ones = ones - 10
    subwf   ones,W          ;0; borrow?
    bc      div10           ;   no, branch, else
    movfw   ones            ;0;
    movwf   dispbuf+2       ;c;
    movfw   tens            ;0;
    movwf   dispbuf+0       ;c;
    swapf   dispbuf+0       ;c;
    movwf   dispbuf+1       ;c;
    movlw   0x0F        
    andwf   dispbuf+1       ;c;
    andwf   dispbuf+0       ;c;
    return
#endif

#if ZEONE
CopyDisp3FirstTo3Last:
    movfw   dispbuf+0
    movwf   dispbuf+5
    movfw   dispbuf+1
    movwf   dispbuf+6
    movfw   dispbuf+2
    movwf   dispbuf+7
    return
#endif
    
;****************************************************************************
;****************************************************************************
WaitKeyPress
    btfsc   button,7        ;c; Loop until button pressed
    goto    WaitKeyPress
    goto    Delay10ms       ;   Debounce and return

;****************************************************************************
;****************************************************************************
WaitKeyRelease
    btfss   button,7        ;c; Loop until button released
    goto    WaitKeyRelease
    goto    Delay10ms       ;   Debounce and return
    
    
    END
   